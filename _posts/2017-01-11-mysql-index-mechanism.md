---
layout: post
title:  "Mysql 5.7 索引使用规则和设计优化"
date:   2017-01-10 09:29:18 +0800 
categories: 数据库
tags: mysql index 数据库索引
author: Tommy.Tesla
mathjax: true
---

本文主要通过半翻译半总结的方式介绍了Mysql的索引基础知识，先从总体上讨论了`Mysql是如何使用索引的`，然后就`组合索引`进行了一些探讨。这些知识并不复杂，不需要专业的数据库学习经验就能搞明白，理解了这些可以帮助开发人员更好的进行数据库索引设计和SQL查询语句的编写。

## 1. Mysql 是如何使用索引的
索引可以帮助我们快速的找到包含指定列值的行。假如没有索引的话，Mysql必须从第一行开始查找整个表，才能找到我们想要的那些行。如果没有索引，表越大，花费的时间也就越大。如果我们在查询条件中指定了某几个列的值，并且这个表恰好有一个建立在这些列上的索引，那么Mysql就可以从数据文件中快速的定位到数据所在的位置，而不用查找整个数据文件。这比不断的一行行读取数据快多了[1]。

大部分Mysql索引（`Primary Key`、`Unique index`和`FullText`）都通过`B树`来存储和实现。也有一些例外：空间数据类型使用的索引是基于`R-树`的；`内存表`还支持`哈希索引`；InnoDB为`Fulltext`索引使用了`逆转链表`[1]。

### 1.1 Mysql索引选取规则
严格意义上讲，如果我们在某一张表上建立了多个索引，那么MySql最终使用哪个索引没有一个明确的规律，但大致可以分为以下几步：
1. 寻找可能的（可选）索引：根据用户的WHERE条件，查看每个字段是否匹配某个索引，如果匹配，就把这个索引加入待选列表中。所谓字段匹配索引有两种情况：1）某个查询字段上建立了`单列索引`；2）某个查询字段按照`最左匹配原则`（下文有详细描述）匹配了某个`组合索引`,即为该组合索引的第一列。3）某几个查询字段按照`最左匹配原则`匹配了某个`组合索引`。可选索引列表可使用`EXPLAIN`查看（possible keys）[3]。待选列表如果为空，GOTO 3.
2. 估算每个可选索引对应的扫描行数，然后选择估算值最小的那个索引作为实际扫描使用的索引,我们把这个叫做`最小估算扫描行数优先原则`。实际使用的索引对应[`EXPLAIN`](https://dev.mysql.com/doc/refman/5.7/en/explain-output.html)中的`key`字段。注意，在InnoDB数据库中，估算的待扫描行数不一定精准，也就是实际扫描的行数可能不是这么多[3]。
3. 如果没找到可用索引的话，再考察查询字段，也就是`Select`之后`Where`之前的那些字段。寻找`查询字段`所匹配的索引，并得到一个可用索引结果集。同样的根据`最小估算扫描行数优先原则`，可以得到最优的索引。如果可用索引结果集仍然为空，那么就会使用`全表扫描(Full table scan)`。

> **`最小估算扫描行数优先原则`**——是指Mysql索引优化器在选择索引时将选用预测扫描行数最少的那个索引。

上述逻辑听起来似乎还是蛮简单的，也是可以被信任的，但是这里我们*并不打算举例子来佐证*，因为实际实验结果可能跟上述步骤描述的还是会不太一样。这是由于有一个东西会“从中捣鬼”（非贬义）——它就是`Mysql索引优化器`。`Mysql索引优化器`在某些情况下会放弃使用索引（哪怕是匹配到了），退化为使用`全表扫描`。这是因为使用索引在有些情况下并不高效，比如索引出来的数据量很大，需要频繁的改变`文件读取指针`去获取数据块，可能效果还不如从头到位把整个表都扫描一边，也省去了去查找索引和频繁重定向读取指针（尤其在磁盘存储器[4]上）带来的开销。

> 本文并没有去研究Mysql在优化的时候是否考虑到了存储器的类型，比如是磁盘还是SSD，对于SSD这种高效随机存储器来说，频繁重定向读取指针几乎不耗时。如果没有考虑到，而只是给这种`频繁读取操作`预设了一个`成本常量（消耗的时间）`参与估算的话，可能优化结果并不恰当。

### 1.2 何时会全表扫描
Mysql搜索优化器最终决定使用全表扫描一般有以下几个场景：
* 1.目标数据表太小了，再去查找索引（`key lookup`）太麻烦了（有点杀鸡焉用牛刀的即视感）。这通常发生在10行都不到的数据表，并且每行很短的情况。（注： 10这个数字不可靠，这里只是感性的说了个数字，可能小几十行的数据仍然会触发全表扫描。）
* 2.查询条件中的字段（WHERE后）没有匹配到索引的情况。（也不是说匹配不到就一定会全表扫描，见上文规则）
* 3.查询条件中的字段值使用的是常量（就比如`where age > 8`)，并且使用这个常量值与对应索引筛选出的记录数占了总数的大部分（至少一半以上）。优化器认为扫这么大的数据还不如扫全表了，所以选择了扫描全表。
* 4.查询语句匹配到的索引对应的基数太小（对应`SHOW INDEX FROM table_name`结果中的`Cardinality` )，并且此时又有其他列上的查询条件。所谓基数就是表中某列所有值的取值种数，比如一张表有5行，某一列对应的值分别为：1,2,3,3,2。那么该列`基数`就是3，因为一共有三种取值：1,2,3。 如果某个单列索引的基数很小，那么我们就要考虑这个索引创建的是否合适。因为基数过小也可能导致该索引失效。基数小，意味着该索引中每一个满足条件的索引值对应的记录数很大，在这个索引值对应的记录数中再去一个个的检查其他列上的条件是否满足，整个过程总体的查找次数还未必有全表扫描来得快。

第4个场景和第3个有点类似，Mysql优化器都是觉得用索引带来的扫描次数和全表扫描没啥区别，用索引还要承担额外频繁切换`文件读取指针`带来的开销，所以还不如使用全表扫描。第4个场景可能有点难懂，所以举一个例子来说明。比如一张表Animal有以下数据：
```
id     |  category  |  name    |  other fields
1            1         asaf          ...
2            2        ikashef        ...
3            3         lksd          ...
...         ...        ...           ...
9999         3         asdf          ...
10000        2         adsfa         ...
```
我们在category上创建了一个索引，然后我们使用以下SQl语句进行查找:
```
Select * from Animal where category > 1 and name = "asaf"
```
这时候category对应的索引数据会如下所示：
```
1 -->  1,...k
2 -->  2,...p...10000
3 -->  3,...q...9999
```
假如使用了Category索引，那么记录检索器第一步会匹配出满足的索引值，即2,3（>1)，而2,3对应的所有数据集都会被比较。待扫描的记录行数可能占了整个表的大部分，Mysql搜索优化器最终选择放弃该索引，退化为全表扫描。

 

## 2. 多列索引(组合索引)
Mysql支持创建`组合索引`（其实就是同时在多个列上创建索引）。一个索引最大可以包含16个列。对于某些数据类型的列来说，你还可以对其前缀进行索引（[前缀索引(https://dev.mysql.com/doc/refman/5.7/en/column-indexes.html#column-indexes-prefix)]）[2]。当查询匹配了索引中的所有列、第一列、前二列、前三列等时，Mysql就会使用这个多列索引，如果我们在定义索引的时候就安排好列的顺序，一个单独的组合索引总是可以加快好几种查询。换句话说，定义好一个组合索引，只要某个查询用到了里面的某些字段，就可能就会命中这个索引[2]。

### 2.1 组合索引的数据构成
单列索引的数据构成很简单，以B树实现为例，每一个索引值对应了一个树的节点，通过树的节点可以快速找到最终对应了哪些记录。那么`组合索引`的索引值构成又是啥样的呢，我们可以把多列索引（`混合索引`)的索引数据当作一个排序好的数组， 索引数据的每一行就是由这些索引列对应的值组合起来的字符串[2]。比如对于`index (a, b, c)`来说，
数据库中有数据：
```
1..."1","2","3"...
2..."6","4","5"...
3..."3","2","9"...
4..."1","2","3"
```
那么索引数据就会像一样：
```
[1] [2] [3]  --> 1,4
[3] [2] [9] --> 3
[6] [4] [5] -->2
```
> 注意： 这是官方举得一个例子。实际查询条件可能是">、<、<="这样的范围比较符号，需要对每一列作比较，所以不会真正的连接成一个字符串，这里只是一个形象的比喻，告知大家`组合索引`和普通索引在数据构成上其实没啥区别。

### 2.2 组合索引的一种替代方案
官方事实上，除了使用多列索引外，我们还有一个选择，那就是在表中增加一列`哈希`列，哈希列的值计算自其他的某几列。如果哈系列很短，唯一性好，并且加了索引，那么它将比直接使用组合索引快得多。在Mysql中，使用这个`哈希`列很简单，比如[2]：
```
SELECT * FROM tbl_name
  WHERE hash_col=MD5(CONCAT(val1,val2))
  AND col1=val1 AND col2=val2;
```
> 很显然，这种方法只适用于精确匹配的情况，如果用到了范围比较符号（>,<,>=等），那就无法使用了。

### 2.3 组合索引的命中规则——最左匹配原则
下面我们再来看看哪些查询会使用到我们定义的组合索引。假设一张表的定义如下：
```
CREATE TABLE test (
    id         INT NOT NULL,
    last_name  CHAR(30) NOT NULL,
    first_name CHAR(30) NOT NULL,
    PRIMARY KEY (id),
    INDEX name (last_name,first_name)
);
```
`name`索引是一个建立在`last_name`和`first_name`上的索引。 这个索引会被那些为`last_name`和`first_name`字段指定了已知范围的查询所使用，当然了，他也会被只指定了`last_name`的查询所使用，因为只指定`last_name`的情况恰好符合了`**最左索引匹配原则**`。我们举些例子来说明下，`name`索引会在以下查询语句被使用到：
``` 
SELECT * FROM test WHERE last_name='Widenius';

SELECT * FROM test
  WHERE last_name='Widenius' AND first_name='Michael';

SELECT * FROM test
  WHERE last_name='Widenius'
  AND (first_name='Michael' OR first_name='Monty');

SELECT * FROM test
  WHERE last_name='Widenius'
  AND first_name >='M' AND first_name < 'N';
```

如果一个表有一个组合索引，那么任何符合`**最左匹配原则**`的查询条件都会触发优化器使用该索引进行数据查找。比如，有一个三列的组合索引`(col1, col2, col3)`,那么当查询：`where col1=xxx` 、`where col1=xxx and col2=xxx`、`where col1=xxx and col2=xxx and col3=xxx`时，都会触发该索引。

> **`最左匹配原则`**——在对查询条件中的字段进行`组合索引`的匹配时，只考虑匹配其前N个字段，比如前一个（第一个）、前2个、前3个字段等。其他情况视为未匹配。

而如果某个查询不满足最左原则，那么Mysql将不会使用该索引。下面我们来举几个例子，如下所示的4个查询语句：
``` 
1. SELECT * FROM tbl_name WHERE col1=val1;
2. SELECT * FROM tbl_name WHERE col1=val1 AND col2=val2;

3. SELECT * FROM tbl_name WHERE col2=val2;
4. SELECT * FROM tbl_name WHERE col2=val2 AND col3=val3;
```

假设我们在` (col1, col2, col3)`上创建了索引，那么只有1和2语句命中了该索引。后面两条语句则不会命中，因为他们不满足`**最左匹配原则**`。然而，其实实际情况中我们在Mysql中做实验的时候，会发现3,4也命中了该索引。 这是因为触发了`默认索引选择算法`选取索引。当Mysql没找到适合的索引，准备退化到全表扫描前，会使用一个`默认索引选择算法`。Mysql认为只要能找到这样一个索引，总会比全表扫描好一点。

> ** `默认索引选择算法`**——当查询语句的搜索条件没有命中任何索引时，Mysql索引优化器会考量查询语句中的目标字段（select后面，where前面的部分），目标字段除去主键外，如果恰好是某个索引（包括组合索引）对应列的子集，那么该索引也会被使用。如果满足的索引有多个，将会使用索引记录数最少的索引。这个算法在[3]中得到了旁证。

比较巧的是，*代表了所有字段，除去了主键外，其他3个字段刚好在上述索引中，所以上述索引被命中。这时候只需要表中再多一个没有被索引的字段`col4`,索引就不会被命中。

还是刚刚的例子，以下查询语句将不会命中`name`索引：
``` 
SELECT * FROM test WHERE first_name='Michael';

SELECT * FROM test
  WHERE last_name='Widenius' OR first_name='Michael';
```
又一次打脸的是，如果你真的建了这么一个表来做实验，使用`Explain`命令进行执行分析时，上述语句的分析结果可能提示使用了该索引。还是因为触发了`默认索引选择算法`。
 

## 3. 索引设计建议
针对以上讨论的Mysql索引的选取规则和命中规则，可以总结出以下开发过程中需要注意的地方：
1. 对于查询条件比较多的情况，避免为每个字段创建索引，只需要创建一个联合索引即可。创建联合索引时，把可能存在单列查询的那一列放前面。比如业务需求要求以下几种查询：
```
... WHERE col1 = xxx, col2 > yyy, col3 < zzz;
... WHERE col2 > yyy, col3 < zzz
... WHERE col2 > yyy
```
这时候，组合索引应该建成为:
```
index(col2, col3, col1)
```
这时候上述三种查询都会使用到该索引。
2. 创建联合索引时，优先为值差异化大的列创建索引，而不是那些取值种类很少的列。比如`用户名`和`用户状态`两列，创建索引的顺序应当是index(用户名、用户状态)，而不是index(用户状态、用户名)






有任何不对的地方，或者有更好的描述，请务必指出，帮助大家更好的进步。


参考文献：
[1]. How MySQL Uses Indexes. https://dev.mysql.com/doc/refman/5.7/en/optimization-indexes.html

[2]. Multiple-Column Indexes, https://dev.mysql.com/doc/refman/5.7/en/multiple-column-indexes.html

[3]. EXPLAIN Output Format. https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_key

[4]. 磁盘存储器. http://www.baike.com/wiki/%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8%E5%99%A8

[5]. Avoiding Full Table Scans. https://dev.mysql.com/doc/refman/5.7/en/table-scan-avoidance.html



* content
{:toc}