---
layout: post
title:  "浅谈微服务体系中的DDD领域设计和分层之道"
date:   2017-09-01 13:29:18 +0800
categories: 架构师
tags: DDD 分层设计 Layered-Architecture
author: Tommy.Tesla
mathjax: true
---

### 1.摘要

本文阐述了一种将DDD领域设计和其主张的分层设计方法应用于微服务体系架构的方案实践，也是个人的最佳实践。这种方案目前在本人所在的公司运作的不错。总结来说，本文主张将一个互联网公司的Web服务架构分为五层：基础设施层、领域服务层、应用服务层、网关层和用户界面层（表示层）。领域服务层和应用服务层均可以采用微服务设计进行拆分，其中领域服务层将严格按照DDD定义的领域模型和模块进行设计。这种方案的确用起来得心应手，把大系统以一种科学的方式分而治之，但同时也对架构师和开发人员提出了更高的要求。本文先阐述了下背景，然后探讨了为什么我们需要分层设计，其原理和好处又是什么，第三部分结合微服务和DDD进行对领域层的服务模块划分和设计。文章的最后部分则就分层设计和DDD建模中常见的问题进行了整理。
 
### 2.背景介绍

想写这样一篇文章很久了，可惜碍于自己能力有限，从08年写代码以来一直断断续续的思考，始终对项目代码结构设计（分包、分层）没有一个可以让自己觉得无瑕疵的答案，假设了某个设计，很快在实践中又会发现其存在着一些问题。直到2014年毕业工作后了解了DDD领域驱动设计后，才有了相对清晰的方向。实际上早在2004年，Eric Envas的《领域驱动设计：软件核心复杂性应对之道》就出版了，毕竟软件开发自计算机普及以来已经存在很长一段时间了，早期国外程序员对软件开发理论的研究也十分兴盛，如今成熟后反而研究的相对少了，基本上依葫芦画瓢即可。**DDD领域驱动设计**对软件设计各个环节的人员都有较高的要求,用《领域驱动设计》一书的话来说它需要一个“领域驱动团队”[1]，它要求从分析阶段，产品经理、项目经理、架构师以及开发工程师就使用统一的模型语言（Ubiquitous Language）来进行沟通，并且他们都懂一些代码、产品和建模相关的知识，事实上这在国内很难实施，国内的产品经理约等于需求整理工，对其计算机基础的要求是少之又少，在我所从事的公司里，也曾发生过产品经理直接指导开发，以至于后面双方理解的同一个词有着不同含义的情况。近年来，随着分布式的发展，传统中小型机集中式服务器已经不在流行，所以微服务体系也成为了各大互联网公司主流的选择。直观的感受下**微服务**和**DDD**两者，似乎一个是把大系统拆成小系统的，另一个则是大系统的设计方法，似乎两者天生互斥，微服务化的小系统也用不着DDD，其实并不是，DDD是针对整个复杂的软件解决方案的一种科学设计方法，微服务化也是把复杂的大系统拆分为小系统，方便维护和管理，所以两者都有一个特点——为复杂的大系统服务。下面咱们就来探讨下，如何把DDD的领域设计和其主张的分层设计应用到微服务体系架构中。需要说明的是本文主要是个人十多年来的一点总结，未必适合所有场景，有更好更易理解的设计方式请不吝赐教。

### 3.分层设计

准确的说分层设计（Layered Architecture）跟DDD没有必然的联系，本人最早接触分层设计是在携程网，当时内部使用的应该只是简单的业务层（Biz）和表示层，数据库访问之类的也是放在各自的业务包下的，后来翻阅和学习了《领域驱动设计：软件核心复杂性应对之道》，书的第4章“分离领域”中说到了四层分层设计，即：基础设施层、领域层、应用层和用户界面层（表示层）。DDD产生的年代微服务还未流行，当时甚至基于浏览器的Web应用都比较少，更多的是PC软件和EJB等网络应用，所以作者更多的是想表达对复杂系统的逻辑分层，并不在意每个领域是单独的系统还是一个软件系统内不同的模块。所以为了跟其做区分，我们建议的四层为在其基础上引入“服务”两个字，即：基础设施层、领域服务层、应用服务层和用户界面层。这样做的意图是让开发人员立刻可以了解到——每个领域模块即一个微服务。摘要中提到我们主张的分层体系中还有一个层，即**网关层**，这又是什么鬼呢。刚刚提到的DDD的时代背景，PC软件系统或者企业内部使用的网络应用系统是根本没有网关这一说的，而现如今互联网公司产品的输出形式无外乎Web应用（网站、或者网络服务），并且为了更好的适配PC站和App，一般会采用**前后端分离**的应用设计方案，这时候会产生一个需求——内部网络应用系统如何把自己的服务输出到互联网上，供外部系统或者浏览器网页访问。最直接的方式就是把应用层直接暴露在公网上，但这样做有以下缺陷：
* 应用层不具备负载均衡的功能。
* 应用层服务可能数量众多，删减频繁，直接发布到公网带来的运维工作量巨大。
* 应用层服务更多的是关注业务应用，对系统安全性（防DDOS、钓鱼、跨域等）、请求监控等缺乏考虑。

这时候我们在Web应用系统中引入网关层用于衔接**表示层**和**应用层**，因为这样可以更好的划分各层的职能。网关层也可以看作是应用服务层的对外包装层。如果一定要把网关层做到应用服务层里理论上也是可行的，但是最佳实践告诉我们，往往应用服务层可能是一个基于Socket的微服务，而对外提供的接口往往是基于Http协议的Restful接口，所以索性增加一个网关层，让应用服务层只关心自己的业务实现，其他安全性，负载均衡，网络控制等交给网关层统一管理。这样我们就得到了以下网络应用系统分层体系：

<img src="/image/layed-arch/layerd-architecture.png" /> 

其中，各层的职能和作用为[2]：
* 用户界面层：负责向用户显示和解释用户指令。这里指的用户可以是另一个计算机系统，不一定是使用用户界面的人（比如外部应用调用对应接口）。
* 网关层： 负责提供对外的HTTP服务或者其他应用层协议（这里是指OSI七层协议中的应用层，别混淆了哈）服务。
* 应用服务层：定义软件要完成的任务，并且指挥表达领域概念的对象来解决问题。这一层所负责的工作对业务来说意义重大，也是与其他系统的应用层进行交互的必要渠道。应用层要尽量简单，不包含业务规则或者知识，而只为下一层中的领域对象协调任务，分配工作，使他们互相协作。它没有反应业务情况的状态，但是却可以具有另外一种状态，为用户或者程序显示某个任务的进度。
* 领域服务层：负责表达业务概念，业务状态信息以及业务规则。尽管保存业务状态的技术细节是由基础设施层实现的，但是反应业务情况的状态是由本层控制并且使用的。**领域层是业务软件的核心。**
* 基础设施层：为上面各层提供通用的技术能力，为应用层传递消息，为领域层提供持久化机制，为用户界面层绘制屏幕组件（PS：这个在互联网应用中几乎用不到）等等。互联网Web应用系统中基础设施包含了数据持久化服务，中间件服务（数据库，Redis，Memcached，zookeeper，ELK等等）以及第三方服务等。

各层除了实现自己的功能外，还需要遵守以下原则：
1. 每一层设计保持内聚，并且只依赖于它的下方的层。
2. 下层向上层发起的通信只能通过中间件等间接方式进行。[2]
3. 上层和下层只能有松散耦合（各自为独立个体，通过简单引用关联）。在某些微服务框架比如Dubbo中，可以把api包提供给上层引用即可。而Spring Cloud的上下层耦合更为松散，通过契约约定即可。前者的优点是调用者可以直接使用提供方定义好的契约和方法。后者的优点则在于最大限度的降低了耦合，避免在上层无限制的进行下层包引入。

这里重点说明应用服务层和领域服务层之间的关系。举一个我经常跟部门其他开发举的一个例子：有一家上市企业A公司，靠卖水果发家，其首席架构师科学合理的按照DDD搭建了一套基于微服务体系的卖水果应用，其架构图如下：

![](/image/layed-arch/fruit-site.png)

今年水果行情一般，而房地产十分火热，A公司高层发现房地产带动的五金行业也十分火热，于是下达任务给技术部，要求其立即着手搭建五金销售系统，货源已经谈好。得益于首席架构师之前优秀的架构设计，他发现只需要做一个卖五金的网站以及另外对微服务进行微量的调整即可满足老板的需求——因为卖五金和卖水果并无本质区别，他们涉及的环节几乎一致。加入五金售卖的系统架构图如下：

![](/image/layed-arch/metal-sale.png)

可见应用服务层代表是某一个业务应用，它代表的更多的是从需求出发的应用定义，而领域服务层则是业务领域按照自身的边界进行设计的一个高内聚的服务体。应用层通过协调和组合各个领域服务即可形成一个新的应用服务。《领域驱动设计》中明确指出，在设计领域服务时无需考虑表示层和持久层服务的东西。我在现实开发中总是遇到大量工程师按照产品的设计稿一溜烟的从上至下设计应用层服务和领域层服务，完全没有考虑业务领域的概念，导致后面微服务数量膨胀，功能重复度高。这种开发习惯代表的是《领域驱动设计》一书中极力吐槽的一种模式——**SMART UI "反模式"**[4]。

### 4.领域服务层的DDD建模

按照DDD提出的理论，只需要在领域服务层进行领域划分和设计即可，实践告诉我们确实是如此，
//TODO

### 参考文献
1. 领域驱动设计：软件核心复杂性应对之道。**Eric Envas**，2016年6月第二版，前言部分。
2. 领域驱动设计：软件核心复杂性应对之道。**Eric Envas**，2016年6月第二版，Page.44。 
3. 领域驱动设计：软件核心复杂性应对之道。**Eric Envas**，2016年6月第二版，Page.45。 
4. 领域驱动设计：软件核心复杂性应对之道。**Eric Envas**，2016年6月第二版，Page.48。 

* content
{:toc}