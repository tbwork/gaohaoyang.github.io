---
layout: post
title:  "JVM运行时内存数据区域"
date:   2018-01-20 21:49:08 +0800
categories: JVM Java概念模型
tags: 虚拟机栈 方法区 Java堆 运行时常量池 
author: Tommy.Tesla
mathjax: true
---

周志明老师写的《深入理解Java虚拟机》应该很多程序员都读过，第二章中阐述了Java虚拟机在执行Java程序的过程中是如何管理内存的，以及这些内存是如何被划分成更细的逻辑区域的。如下图所示，按照书中的论述JVM运行时数据区域包含以下几个数据区。

![](/image/java-memory-parts/parts-in-book.png)

按照《Java虚拟机规范（Java SE 7版）》，各区域的功能简要介绍如下：
* 程序计数器：各线程私有。用于记录每个线程当前执行到的字节指令行号以及相关信息。这是唯一的不会抛出OOM异常的区域。
* Java虚拟机栈：各线程私有。虚拟机栈由一个个的栈帧组成，每个栈帧包含了对应方法执行所需要的信息，具体包括：局部变量表、操作数栈（类似于编译型语言体系下的数据寄存器）、动态链接（某些接口符号可能会动态的指向不同的目标方法）、函数返回地址以及其他一些相关信息。理论上当函数调用链超过栈的深度时就会触发StackOverflow，当该区域设置为动态扩展时，虚拟机无法为栈申请到更多内存时就会触发OOM。事实中基本上不管哪种情况，结果都很可能会是StackOverflow，因为栈容量和栈帧的大小决定了栈的深度（栈帧大小*深度<=栈容量），所以当OOM时，栈深度一定也已经不够用了，所以抛出StackOverflow异常也无可厚非。可以通过“-Xss”来配置虚拟机栈固定大小。
* Java堆：各线程公有。虚拟机工作的主要内存区域（大部分情况下也是最大的），绝大部分对象实例的内存分配都在这里进行。Java 7和之前的Java堆细分为：新生代（伊甸区、存活区0、存活区1）、年老代和永久代。Java 8去除了永久代，替换以Metaspace。在JVM的运行中，大部分情况下，GC主要就发生在堆区域，
* 方法区：各线程公有。用于存放类定义、常量池、静态变量（static修饰）、编译后的字节码等。方法区实际上是从堆上划分出来的一块区域，但是其GC机制是单独的，与堆不同，所以为了区分方法区和堆，通常又把方法区叫做“非堆”。方法区对应了堆中的永久代。因此在Java8以及之后版本中，永久代被抹除了，方法区也移到了元数据空间（metaspace）中。
* 运行时常量池：各线程公有。用于存放类信息中的常量（字面量、符号引用等），每个类编译后的信息中的都有一个常量池，可以通过javap -vebose xxxx.class命令来查看。
* 直接内存：进程间公有。直接内存不属于Java虚拟机运行时数据区的一部分，它是指操作系统分配给虚拟机以及其他进程所运行的那块内存区域，之所以这么说，是因为很多服务器都是虚拟机（操作系统级别），对于物理机来说，这块内存就是指操作系统所管控的物理内存。通过在堆中创建一个DirectByteBuffer实例来对直接内存进行访问。

很多读者了解完这些后还是云里雾里，各论坛还是会出现各种没有定论的问题，比如
1. 字符串常量池属于哪个数据区?
2. Java6、Java7和Java8的运行时内存数据区域到底有何不一样？
3. 什么是字面量，什么又是字符串常量？

下面我们围绕这三个问题做一些讨论和引申，从而帮助我们更好的理解运行时数据区域划分。我们先来回答第二个问题。以下三张图分别代表了Java6、Java7和Java8体系下的Java虚拟机与运行时数据区域划分。

![Java 6 内存数据区域划分](/image/java-memory-parts/java6.png)
![Java 7 内存数据区域划分](/image/java-memory-parts/java7.png)
![Java 8 内存数据区域划分](/image/java-memory-parts/java8.png)






* content
{:toc}